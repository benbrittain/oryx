use async_trait::async_trait;
use cas::ContentAddressableStorage;
use common::Digest;
use std::future::Future;
use std::path::Path;
use std::path::PathBuf;
use thiserror::Error;
use tokio::sync::mpsc;
use uuid::Uuid;

mod engine;
pub mod hermetic;
pub mod insecure;

pub use engine::{ExecuteStage, ExecuteStatus, ExecutionEngine};

#[derive(Default, Debug)]
pub struct Command {
    pub arguments: Vec<String>,
    pub env_vars: Vec<(String, String)>,
}

/// Information on a digest reified into the filesystem.
#[derive(Clone, Debug)]
pub enum Entry {
    File {
        path: PathBuf,
        digest: Digest,
        executable: bool,
    },
    Directory {
        path: PathBuf,
        digest: Digest,
    },
    Symlink {
        original: PathBuf,
        link: PathBuf,
    },
}

/// Description of how to layout execution directory structure
#[derive(Default, Debug)]
pub struct DirectoryLayout {
    /// Entries for laying out directory structure before execution.
    pub entries: Vec<Entry>,
    /// Expected paths to be generated by execution.
    pub output_paths: Vec<PathBuf>,
}

#[derive(Debug, Error)]
pub enum ExecuteError {
    #[error("One or more arguments are invalid: {0}")]
    InvalidArgument(String),
    #[error("A Blob was not found when setting up the action was requested. The client may be able to fix the errors and retry. {0}")]
    BlobNotFound(Digest),
    #[error("An internal I/O error occured. {0}")]
    IoError(#[from] std::io::Error),
    #[error("An internal error occurred in the content store: {0}")]
    CasError(#[from] cas::CasError),
    #[error("An internal error occurred in the execution engine or the worker: {0}")]
    Internal(String),
}

#[derive(Debug)]
pub struct ExecuteResponse {
    pub exit_status: i32,
    pub output_paths: Vec<Entry>,
    pub stderr: Vec<u8>,
    pub stdout: Vec<u8>,
}

#[async_trait]
pub trait ExecutionBackend: Send + Sync + 'static + Clone {
    /// Run a command on an arbitrary Execution backend.
    ///
    /// Takes a command and a directory layout.
    ///
    /// Returns an Execute Response.
    async fn run_command(
        &self,
        command: Command,
        dir: DirectoryLayout,
    ) -> Result<ExecuteResponse, ExecuteError>;
}
