use anyhow::Error;
use async_trait::async_trait;
use common::Digest;
use std::future::Future;
use std::path::PathBuf;
use tokio::sync::mpsc;
use uuid::Uuid;

pub mod insecure;

#[derive(Default, Debug)]
pub struct Command {
    pub arguments: Vec<String>,
    pub env_vars: Vec<(String, String)>,
}

/// Information on a digest reified into the filesystem.
#[derive(Default, Clone, Debug)]
pub struct Entry {
    pub path: PathBuf,
    pub digest: Digest,
    pub executable: bool,
}

/// Description of how to layout execution directory structure
#[derive(Default, Debug)]
pub struct DirectoryLayout {
    /// Files for laying out directory structure before execution.
    pub files: Vec<Entry>,
    /// Expected paths to be generated by execution.
    pub output_paths: Vec<PathBuf>,
}

#[derive(Debug)]
pub struct ExecuteStatus {
    pub uuid: Uuid,
    pub action_digest: Digest,
    pub stage: ExecuteStage,
}

#[derive(Debug)]
pub enum ExecuteStage {
    Queued,
    Running,
    Done(ExecuteResponse),
}

#[derive(Debug)]
pub struct CommandResponse {
    pub exit_status: i32,
    pub output_paths: Vec<(PathBuf, PathBuf)>,
    pub stderr: Vec<u8>,
    pub stdout: Vec<u8>,
}

#[derive(Debug)]
pub struct ExecuteResponse {
    pub exit_status: i32,
    pub output_paths: Vec<Entry>,
    pub stderr: Vec<u8>,
    pub stdout: Vec<u8>,
}

pub struct ExecutionEngine<B> {
    backend: B,
}

impl<B: ExecutionBackend> ExecutionEngine<B> {
    pub fn new(backend: B) -> Self {
        ExecutionEngine { backend }
    }

    pub fn execute<Exec, Verify>(
        &self,
        setup_func: impl Fn() -> Exec + Send + Sync + 'static,
        verify_func: impl Fn(Vec<(PathBuf, PathBuf)>) -> Verify + Send + Sync + 'static,
    ) -> Result<mpsc::Receiver<ExecuteStatus>, Error>
    where
        Exec: Future<Output = anyhow::Result<(Digest, Command, DirectoryLayout)>> + Send,
        Verify: Future<Output = anyhow::Result<Vec<Entry>>> + Send,
    {
        let (tx, rx) = mpsc::channel(32);
        let backend = self.backend.clone();
        let uuid = Uuid::new_v4();
        tokio::spawn(async move {
            // Run the actual command using the backend.
            let (action_digest, cmd, layout) = setup_func().await?;

            log::info!("================= {uuid} | Queued =================");
            tx.send(ExecuteStatus {
                uuid: uuid,
                action_digest: action_digest.clone(),
                stage: ExecuteStage::Queued,
            })
            .await?;

            // TODO scheduling logic here
            log::info!("================= {uuid} | Running =================");
            tx.send(ExecuteStatus {
                uuid: uuid,
                action_digest: action_digest.clone(),
                stage: ExecuteStage::Running,
            })
            .await?;

            // Run the actual command using the backend.
            let mut resp = backend.run_command(cmd, layout).await?;

            log::info!("================= {uuid} | Verifying =================");
            let output_paths: Vec<Entry> = verify_func(resp.output_paths).await?;

            log::info!("================= {uuid} | Done =================");
            tx.send(ExecuteStatus {
                uuid: uuid,
                action_digest: action_digest.clone(),
                stage: ExecuteStage::Done(ExecuteResponse {
                    exit_status: resp.exit_status,
                    output_paths,
                    stderr: resp.stderr,
                    stdout: resp.stdout,
                }),
            })
            .await?;

            // TODO caching logic here
            anyhow::Ok(())
        });

        Ok(rx)
    }
}

#[async_trait]
pub trait ExecutionBackend: Send + Sync + 'static + Clone {
    async fn run_command(
        &self,
        command: Command,
        dir: DirectoryLayout,
    ) -> Result<CommandResponse, Error>;
}
